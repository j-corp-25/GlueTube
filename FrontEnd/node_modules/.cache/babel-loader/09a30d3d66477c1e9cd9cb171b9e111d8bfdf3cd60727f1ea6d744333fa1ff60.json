{"ast":null,"code":"export default async function csrfFetch(url, options = {}) {\n  // set options.method to 'GET' if there is no method\n  options.method = options.method || \"GET\";\n  // set options.headers to an empty object if there are no headers\n  options.headers = options.headers || {};\n\n  // if the options.method is not 'GET', then set the \"Content-Type\" header to\n  // \"application/json\" and the \"X-CSRF-Token\" header to the value of the\n  // \"X-CSRF-Token\" cookie\n  if (options.method.toUpperCase() !== \"GET\") {\n    options.headers[\"Content-Type\"] = options.headers[\"Content-Type\"] || \"application/json\";\n    options.headers[\"X-CSRF-Token\"] = sessionStorage.getItem(\"X-CSRF-Token\");\n  }\n\n  // call fetch with the url and the updated options hash\n  const res = await fetch(url, options);\n\n  // if the response status code is 400 or above, then throw an error with the\n  // error being the response\n  if (res.status >= 400) throw res;\n\n  // if the response status code is under 400, then return the response to the\n  // next promise chain\n  return res;\n}\n\n// export function storeCSRFToken(response) {\n//   const csrfToken = response.headers.get(\"X-CSRF-Token\");\n//   if (csrfToken) sessionStorage.setItem(\"X-CSRF-Token\", csrfToken);\n// }\n\n// export async function restoreCSRF() {\n//   const response = await csrfFetch(\"/api/session\");\n//   storeCSRFToken(response);\n//   return response;\n// }","map":{"version":3,"names":["csrfFetch","url","options","method","headers","toUpperCase","sessionStorage","getItem","res","fetch","status"],"sources":["/Users/jordycorporan/Desktop/glue_tube/FrontEnd/glue_tube/src/store/csrf.js"],"sourcesContent":["export default async function csrfFetch(url, options = {}) {\n  // set options.method to 'GET' if there is no method\n  options.method = options.method || \"GET\";\n  // set options.headers to an empty object if there are no headers\n  options.headers = options.headers || {};\n\n  // if the options.method is not 'GET', then set the \"Content-Type\" header to\n  // \"application/json\" and the \"X-CSRF-Token\" header to the value of the\n  // \"X-CSRF-Token\" cookie\n  if (options.method.toUpperCase() !== \"GET\") {\n    options.headers[\"Content-Type\"] =\n      options.headers[\"Content-Type\"] || \"application/json\";\n    options.headers[\"X-CSRF-Token\"] = sessionStorage.getItem(\"X-CSRF-Token\");\n  }\n\n  // call fetch with the url and the updated options hash\n  const res = await fetch(url, options);\n\n  // if the response status code is 400 or above, then throw an error with the\n  // error being the response\n  if (res.status >= 400) throw res;\n\n  // if the response status code is under 400, then return the response to the\n  // next promise chain\n  return res;\n}\n\n// export function storeCSRFToken(response) {\n//   const csrfToken = response.headers.get(\"X-CSRF-Token\");\n//   if (csrfToken) sessionStorage.setItem(\"X-CSRF-Token\", csrfToken);\n// }\n\n// export async function restoreCSRF() {\n//   const response = await csrfFetch(\"/api/session\");\n//   storeCSRFToken(response);\n//   return response;\n// }\n"],"mappings":"AAAA,eAAe,eAAeA,SAASA,CAACC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACzD;EACAA,OAAO,CAACC,MAAM,GAAGD,OAAO,CAACC,MAAM,IAAI,KAAK;EACxC;EACAD,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACE,OAAO,IAAI,CAAC,CAAC;;EAEvC;EACA;EACA;EACA,IAAIF,OAAO,CAACC,MAAM,CAACE,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;IAC1CH,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC,GAC7BF,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC,IAAI,kBAAkB;IACvDF,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC,GAAGE,cAAc,CAACC,OAAO,CAAC,cAAc,CAAC;EAC1E;;EAEA;EACA,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAACR,GAAG,EAAEC,OAAO,CAAC;;EAErC;EACA;EACA,IAAIM,GAAG,CAACE,MAAM,IAAI,GAAG,EAAE,MAAMF,GAAG;;EAEhC;EACA;EACA,OAAOA,GAAG;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}